//
//  SwiftGenerator.swift
//  WeaverCodeGen
//
//  Created by ThÃ©ophane Rupin on 3/2/18.
//

import Foundation
import PathKit
import Meta

public final class SwiftGenerator {
    
    private let dependencyGraph: DependencyGraph
    
    private let detailedResolvers: Bool
    
    private let version: String
    
    public init(dependencyGraph: DependencyGraph,
                detailedResolvers: Bool,
                version: String) throws {

        self.dependencyGraph = dependencyGraph
        self.detailedResolvers = detailedResolvers
        self.version = version
    }
    
    public func generate() throws -> [(file: String, data: String?)] {
        
        return try dependencyGraph.dependencyContainersByFile.orderedKeys.lazy.map {
            MetaWeaverFile(fileName: $0,
                           dependencyGraph: self.dependencyGraph,
                           version: self.version,
                           detailedResolvers: self.detailedResolvers)
        }.compactMap {
            guard let swiftString = try $0.meta()?.swiftString else { return nil }
            return ($0.fileName, swiftString)
        }
    }
    
    public func generate() throws -> String? {
        
        guard dependencyGraph.dependencyContainersByFile.orderedKeys.isEmpty == false else {
            return nil
        }
        
        let files = dependencyGraph.dependencyContainersByFile.orderedKeys.lazy.map {
            MetaWeaverFile(fileName: $0,
                           dependencyGraph: self.dependencyGraph,
                           version: self.version,
                           detailedResolvers: self.detailedResolvers)
        }

        return Meta.File(name: "Weaver.swift")
            .adding(imports: files.flatMap { $0.imports })
            .adding(members: MetaWeaverFile.header(version))
            .adding(members: try files.flatMap { try $0.meta() })
            .swiftString
    }
}

// MARK: - Meta

private struct MetaWeaverFile {
    
    let fileName: String
    
    let dependencyGraph: DependencyGraph
    
    let version: String
    
    let detailedResolvers: Bool
    
    static func header(_ version: String) -> [Comment] {
        return [
            .documentation("This file is generated by Weaver \(version)"),
            .documentation("DO NOT EDIT!")
        ]
    }

    var imports: [Import] {
        return dependencyGraph.importsByFile[fileName]?.map { Import(name: $0) } ?? []
    }

    func meta() throws -> Meta.File? {
        
        let fileBodyMembers: [FileBodyMember] = try meta()
        guard fileBodyMembers.isEmpty == false else { return nil }
        
        return File(name: fileName)
            .adding(members: MetaWeaverFile.header(version))
            .adding(imports: imports)
            .adding(members: fileBodyMembers)
    }
    
    func meta() throws -> [FileBodyMember] {

        let dependencyContainers = try dependencyGraph.dependencyContainers(for: fileName)
        guard dependencyContainers.isEmpty == false else { return [] }

        return try dependencyContainers.flatMap {
            try MetaDependencyContainer(dependencyContainer: $0,
                                        dependencyGraph: dependencyGraph,
                                        fileName: fileName,
                                        detailedResolvers: detailedResolvers).meta()
        }
    }
}

private struct MetaDependencyContainer {
    
    let dependencyContainer: DependencyContainer
    
    let dependencyGraph: DependencyGraph
    
    let fileName: String

    let detailedResolvers: Bool

    func meta() throws -> [FileBodyMember] {
        
        guard dependencyContainer.hasDependencies else { return [] }
        
        var members = [FileBodyMember]()
        
        members.append(EmptyLine())
        members.append(Comment.mark(try targetType().name))
        
        if let inputDependencyResolver = try inputDependencyResolver() {
            members.append(EmptyLine())
            members.append(inputDependencyResolver)
        }
        
        if let parameterResolver = try parameterResolver() {
            members.append(EmptyLine())
            members.append(parameterResolver)
        }
        
        if let dependencyResolver = try dependencyResolver() {
            members.append(EmptyLine())
            members.append(dependencyResolver)
        }
        
        members.append(EmptyLine())
        members.append(try _dependencyContainer())
        
        if dependencyContainer.doesSupportObjc {
            members.append(EmptyLine())
            members.append(Type(identifier: try targetType().objcDependencyInjectableTypeID)
                .with(kind: .protocol)
                .adding(inheritedType: TypeIdentifier(name: "AnyObject"))
            )
        }
        
        if let shimDependencyContainer = try shimDependencyContainer() {
            members.append(EmptyLine())
            members.append(shimDependencyContainer)
        }
        
        if let dependencyContainerPublicInitializer = try dependencyContainerPublicInitializer() {
            members.append(EmptyLine())
            members.append(dependencyContainerPublicInitializer)
        }
        
        return members
    }
    
    private func targetType(of dependencyContainer: DependencyContainer? = nil) throws -> SwiftType {
        guard let type = (dependencyContainer ?? self.dependencyContainer).type else {
            throw SwiftGeneratorError.dependencyContainerIsMissingTypeInFile(fileName)
        }
        return type
    }
    
    private func inputDependencyResolver() throws -> Type? {
        guard dependencyContainer.allReferences.isEmpty == false else { return nil }
        
        return Type(identifier: try targetType().inputDependencyResolverTypeID)
            .with(kind: .protocol)
            .adding(inheritedType: TypeIdentifier(name: "AnyObject"))
            .adding(members: try dependencyContainer.allReferences.map { reference in
                try resolverMember(for: reference)
            })
    }
    
    private func parameterResolver() throws -> Type? {
        guard detailedResolvers else { return nil }
        guard try targetType().genericNames.isEmpty else { return nil }
        guard dependencyContainer.parameters.isEmpty == false else { return nil }
        
        return Type(identifier: try targetType().parameterResolverTypeID)
            .with(kind: .protocol)
            .adding(inheritedType: TypeIdentifier(name: "AnyObject"))
            .with(objc: dependencyContainer.configuration.doesSupportObjc)
            .adding(members: dependencyContainer.parameters.orderedValues.map { parameter in
                ProtocolProperty(name: parameter.dependencyName, type: parameter.abstractType.typeID)
            })
    }
    
    private func dependencyResolver() throws -> FileBodyMember? {
        guard try targetType().genericNames.isEmpty else { return nil }
        
        if detailedResolvers {
            let hasParameterResolver = try parameterResolver() != nil
            guard hasParameterResolver || dependencyContainer.resolverDependencies.isEmpty == false else { return nil }
            
            return TypeAlias(identifier: try targetType().dependencyResolverTypeID.typealiasID, values: [
                hasParameterResolver ? [try targetType().parameterResolverTypeID] : [],
                dependencyContainer.resolverDependencies.map { dependency in
                    dependency.abstractType.resolverTypeID
                }
            ].flatMap { $0 })
        } else {
            return Type(identifier: try targetType().dependencyResolverTypeID)
                .with(kind: .protocol)
                .adding(inheritedType: TypeIdentifier(name: "AnyObject"))
                .with(objc: dependencyContainer.doesSupportObjc)
                .adding(members: dependencyContainer.parameters.orderedValues.map { parameter in
                    ProtocolProperty(name: parameter.dependencyName, type: parameter.abstractType.typeID)
                })
                .adding(members: try dependencyContainer.resolverDependencies.map { dependency in
                    try resolverMember(for: dependency)
                })
        }
    }
    
    private func resolverMember(for dependency: ResolvableDependency) throws -> TypeBodyMember {
        let dependencyContainer = try dependencyGraph.dependencyContainer(for: dependency)
        if dependency.configuration.customBuilder != nil || dependencyContainer.parameters.isEmpty {
            return ProtocolProperty(name: dependency.dependencyName, type: dependency.abstractType.typeID)
        } else {
            return ProtocolFunction(name: dependency.dependencyName)
                .with(parameters: dependencyContainer.parameters.orderedValues.map { $0.functionParameter })
                .with(resultType: dependency.abstractType.typeID)
        }
    }
    
    private func _dependencyContainer() throws -> Type {
        
        return Type(identifier: try targetType().dependencyContainerTypeID)
            .with(kind: .class(final: true))
            .with(genericParameters: try targetType().genericNames.map { GenericParameter(name: $0) })
            .with(objc: dependencyContainer.doesSupportObjc)
            .adding(inheritedType: dependencyContainer.doesSupportObjc ? TypeIdentifier(name: "NSObject") : nil)
            .adding(inheritedType: try dependencyResolver() != nil ? try targetType().dependencyResolverTypeID : nil)
            .adding(inheritedTypes: try dependencyContainer.registrations.orderedValues.compactMap { registration in
                let dependencyContainer = try dependencyGraph.dependencyContainer(for: registration)
                guard dependencyContainer.allReferences.isEmpty == false else { return nil }
                return try targetType(of: dependencyContainer).inputDependencyResolverTypeID
            })
            .adding(members: dependencyContainer.parameters.orderedValues.flatMap { parameter -> [TypeBodyMember] in
                [
                    EmptyLine(),
                    Property(variable: Variable(name: parameter.dependencyName)
                        .with(type: parameter.abstractType.typeID))
                ]
            })
            .adding(members: dependencyContainer.allReferences.flatMap { reference -> [TypeBodyMember] in
                [
                    EmptyLine(),
                    Property(variable: Variable(name: reference.dependencyName)
                        .with(type: reference.abstractType.typeID)),
                ]
            })
            .adding(members: try dependencyContainer.registrations.orderedValues.flatMap { registration -> [TypeBodyMember] in
                var members = [TypeBodyMember]()
                members.append(EmptyLine())
                if registration.configuration.scope != .transient {
                    members.append(try registration.privateProperty(
                        with: registration.configuration.scope == .weak ? .weak : .default
                    ).with(value: Value.nil))
                }
                members.append(try dependencyResolverImplementation(for: registration))
                return members
            })
            .adding(member: EmptyLine())
            .adding(member: try dependencyContainerInit())
    }
    
    private func dependencyResolverImplementation(for registration: ResolvableDependency) throws -> TypeBodyMember {
        let dependencyContainer = try dependencyGraph.dependencyContainer(for: registration)
        
        if dependencyContainer.parameters.isEmpty == false {
            return Function(kind: .named(registration.dependencyName))
                .with(resultType: registration.abstractType.typeID)
                .with(parameters: dependencyContainer.parameters.orderedValues.map { parameter in
                    FunctionParameter(name: parameter.dependencyName, type: parameter.abstractType.typeID)
                })
                .adding(members: try dependencyResolverImplementationBody(for: registration))
        } else {
            return ComputedProperty(variable: Variable(name: registration.dependencyName)
                .with(type: registration.abstractType.typeID))
                .adding(members: try dependencyResolverImplementationBody(for: registration))
        }
    }
    
    private func dependencyResolverImplementationBody(for registration: ResolvableDependency) throws -> [FunctionBodyMember] {
        var members = [FunctionBodyMember]()
        let dependencyContainer = try dependencyGraph.dependencyContainer(for: registration)

        let valueVariable = Variable(name: "value").with(type: registration.abstractType.typeID)
        if registration.configuration.scope != .transient {
            members.append(
                If(assignment: Assignment(variable: valueVariable, value: registration.privateVariable.reference))
                    .adding(member: Return(value: valueVariable.reference))
            )
        }
        
        if let customBuilder = registration.configuration.customBuilder {
            members.append(
                Assignment(
                    variable: valueVariable,
                    value: .named(customBuilder) | .call(Tuple()
                        .adding(parameter: TupleParameter(value: Reference.named(.`self`)))
                    )
                )
            )
        } else if dependencyContainer.hasBuilder {
            let dependenciesVariable = Variable(name: "dependencies")
            members += [
                Assignment(
                    variable: dependenciesVariable,
                    value: try targetType(of: dependencyContainer).dependencyContainerTypeID.reference | .call(Tuple()
                        .adding(parameter: dependencyContainer.allReferences.isEmpty == false ?
                            TupleParameter(name: "injecting", value: Reference.named(.`self`))
                            : nil
                        )
                        .adding(parameters: dependencyContainer.parameters.orderedValues.map { $0.tupleParameter })
                    )
                ),
                Assignment(
                    variable: valueVariable,
                    value: registration.type.typeID.reference | .call(Tuple()
                        .adding(parameter: TupleParameter(name: "injecting", value: dependenciesVariable.reference))
                    )
                )
            ]
        } else {
            members.append(
                Assignment(
                    variable: valueVariable,
                    value: registration.type.typeID.reference | .call(Tuple()
                        .adding(parameter: dependencyContainer.hasDependencies ?
                            TupleParameter(name: "injecting", value: try targetType(of: dependencyContainer).dependencyContainerTypeID.reference | .call())
                            : nil
                        )
                    )
                )
            )
        }
        
        if registration.configuration.scope != .transient {
            members.append(Assignment(
                variable: registration.privateVariable.reference,
                value: valueVariable.reference
            ))
        }
        
        members.append(Return(value: valueVariable.reference))
        
        return members
    }
    
    private func dependencyContainerInit() throws -> Function {
        
        var parameters = [FunctionParameter]()
        if dependencyContainer.allReferences.isEmpty == false {
            parameters.append(FunctionParameter(alias: "injecting",
                                                name: "dependencies",
                                                type: try targetType().inputDependencyResolverTypeID))
        }
        parameters += dependencyContainer.parameters.orderedValues.map { $0.functionParameter }
        
        return Function(kind: .`init`)
            .with(override: dependencyContainer.doesSupportObjc && parameters.isEmpty)
            .adding(parameters: parameters)
            .adding(members: dependencyContainer.parameters.orderedValues.map { parameter in
                Assignment(
                    variable: .named(.`self`) + parameter.variable.reference,
                    value: parameter.variable.reference
                )
            })
            .adding(members: try dependencyContainer.allReferences.map { reference in
                let dependencyContainer = try dependencyGraph.dependencyContainer(for: reference)
                return Assignment(
                    variable: reference.variable.reference,
                    value: .named("dependencies") + reference.callReference(dependencyContainer)
                )
            })
            .adding(member: dependencyContainer.doesSupportObjc ? .named("super") + .named(.`init`) | .call() : nil)
            .adding(members: try dependencyContainer.registrations.orderedValues.compactMap { registration in
                switch registration.configuration.scope {
                case .transient,
                     .weak:
                    return nil
                case .container,
                     .graph:
                    let dependencyContainer = try dependencyGraph.dependencyContainer(for: registration)
                    return Assignment(
                        variable: Reference.named("_"),
                        value: registration.callReference(dependencyContainer)
                    )
                }
            })
    }
    
    private func shimDependencyContainer() throws -> Type? {
        
        guard dependencyContainer.isPublic else { return nil }
        guard dependencyContainer.allReferences.isEmpty == false else { return nil }
        
        return Type(identifier: try targetType().shimDependencyContainerTypeID)
            .with(genericParameters: try targetType().genericNames.map { GenericParameter(name: $0) })
            .adding(inheritedType: try targetType().inputDependencyResolverTypeID)
            .adding(member: EmptyLine())
            .adding(members: dependencyContainer.allReferences.map { reference in
                Property(variable: reference.variable
                    .with(type: reference.abstractType.typeID)
                    .with(immutable: true))
            })
            .adding(member: EmptyLine())
            .adding(member: Function(kind: .`init`)
                .adding(parameters: dependencyContainer.allReferences.map { $0.functionParameter })
                .adding(members: dependencyContainer.allReferences.map { reference in
                    Assignment(
                        variable: .named(.`self`) + reference.variable.reference,
                        value: reference.variable.reference
                    )
                })
            )
    }
    
    private func dependencyContainerPublicInitializer() throws -> Extension? {
        
        guard dependencyContainer.isPublic else { return nil }
        
        let shimAssignment = dependencyContainer.allReferences.isEmpty == false ?
            Assignment(
                variable: Variable(name: "shim"),
                value: try targetType().shimDependencyContainerTypeID.reference | .call(Tuple()
                    .adding(parameters: dependencyContainer.allReferences.map { $0.tupleParameter })
                )
            ) : nil
       
        let dependenciesVariable = Variable(name: "dependencies")
        
        return Extension(name: try targetType().typeID.name.string)
            .with(accessLevel: .public)
            .adding(member: EmptyLine())
            .adding(member: Function(kind: .`init`(convenience: true, optional: false))
                .adding(parameters: dependencyContainer.allReferences.map { $0.functionParameter })
                .adding(parameters: dependencyContainer.parameters.orderedValues.map { $0.functionParameter })
                .adding(member: shimAssignment)
                .adding(member: Assignment(
                    variable: dependenciesVariable,
                    value: try targetType().dependencyContainerTypeID.reference | .call(Tuple()
                        .adding(parameter: shimAssignment != nil ? TupleParameter(name: "injecting", value: Reference.named("shim")) : nil)
                        .adding(parameters: dependencyContainer.parameters.orderedValues.map { $0.tupleParameter })
                    )
                ))
                .adding(member: .named(.`self`) + .named(.`init`) | .call(Tuple()
                    .adding(parameter: TupleParameter(name: "injecting", value: dependenciesVariable.reference))
                ))
            )
    }
}

// MARK: - Utils

private extension DependencyGraph {
    
    func dependencyContainers(for fileName: String) throws -> [DependencyContainer] {
        guard let dependencyContainers = dependencyContainersByFile[fileName] else {
            throw SwiftGeneratorError.dependencyContainersNotFoundForFileName(fileName)
        }
        return dependencyContainers
    }
    
    func dependencyContainer(for dependency: ResolvableDependency) throws -> DependencyContainer {
        guard let dependencyContainer = dependencyContainersByName[dependency.dependencyName] else {
            throw SwiftGeneratorError.dependencyContainersNotFoundForFileName(dependency.dependencyName)
        }
        return dependencyContainer
    }
}

private extension SwiftType {
    
    var typeID: TypeIdentifier {
        return TypeIdentifier(name: name)
            .adding(genericParameters: genericNames.map { TypeIdentifier(name: $0) })
    }
    
    var dependencyContainerTypeID: TypeIdentifier {
        return TypeIdentifier(name: "\(name)DependencyContainer")
    }
    
    var inputDependencyResolverTypeID: TypeIdentifier {
        return TypeIdentifier(name: "\(name)InputDependencyResolver")
    }
    
    var dependencyResolverTypeID: TypeIdentifier {
        return TypeIdentifier(name: "\(name)DependencyResolver")
    }
    
    var parameterResolverTypeID: TypeIdentifier {
        return TypeIdentifier(name: "\(name)ParameterResolver")
    }
    
    var resolverTypeID: TypeIdentifier {
        return TypeIdentifier(name: "\(name)Resolver")
    }
    
    var objcDependencyInjectableTypeID: TypeIdentifier {
        return TypeIdentifier(name: "\(name)ObjCDependencyInjectable")
    }
    
    var shimDependencyContainerTypeID: TypeIdentifier {
        return TypeIdentifier(name: "\(name)ShimDependencyContainer")
    }
}

private extension TypeIdentifier {
    
    var typealiasID: TypeAliasIdentifier {
        return TypeAliasIdentifier(name: name)
    }
}

private extension DependencyContainer {
    
    var hasDependencies: Bool {
        return !registrations.orderedValues.isEmpty || !references.orderedValues.isEmpty || !parameters.orderedValues.isEmpty
    }
    
    var allReferences: [ResolvableDependency] {
        var visitedDependencyContainters = Set<DependencyContainer>()
        return collectAllReferences(&visitedDependencyContainters)
    }
    
    private func collectAllReferences(_ visitedDependencyContainers: inout Set<DependencyContainer>) -> [ResolvableDependency] {
        guard !visitedDependencyContainers.contains(self) else { return [] }
        visitedDependencyContainers.insert(self)
        
        let directReferences = references.orderedValues
        let indirectReferences = registrations.orderedValues.flatMap { $0.target.collectAllReferences(&visitedDependencyContainers) }
        
        let referencesByName = OrderedDictionary<String, ResolvableDependency>()
        (directReferences + indirectReferences).forEach {
            referencesByName[$0.dependencyName] = $0
        }
        
        let registrationNames = Set(registrations.orderedValues.map { $0.dependencyName })
        return referencesByName.orderedValues.filter {
            !registrationNames.contains($0.dependencyName)
        }
    }
    
    var hasBuilder: Bool {
        return parameters.isEmpty == false || allReferences.isEmpty == false
    }
    
    var isPublic: Bool {
        switch accessLevel {
        case .internal:
            return false
        case .public,
             .open:
            return true
        }
    }
    
    var resolverDependencies: [ResolvableDependency] {
        return references.orderedValues + registrations.orderedValues
    }
}

private extension Dependency {
    
    func privateProperty(with kind: VariableKind) throws -> Property {
        return Property(variable: privateVariable
            .with(kind: kind)
            .with(type: .optional(wrapped: abstractType.typeID)))
            .with(accessLevel: .private)
    }
    
    var privateVariable: Variable {
        return Variable(name: "_\(dependencyName)").with(immutable: false)
    }
    
    var tupleParameter: TupleParameter {
        return TupleParameter(name: dependencyName, value: Reference.named(dependencyName))
    }
    
    var functionParameter: FunctionParameter {
        return FunctionParameter(name: dependencyName, type: abstractType.typeID)
    }
    
    var variable: Variable {
        return Variable(name: dependencyName)
    }
    
    func callReference(_ dependencyContainer: DependencyContainer) -> Reference {
        return variable.reference | (dependencyContainer.parameters.isEmpty ? .none : .call(Tuple()
            .adding(parameters: dependencyContainer.parameters.orderedValues.map { $0.tupleParameter })
        ))
    }
}
